diff --git a/Xext/panoramiXprocs.c b/Xext/panoramiXprocs.c
index 9eb29bd..18f3ac7 100644
--- a/Xext/panoramiXprocs.c
+++ b/Xext/panoramiXprocs.c
@@ -106,7 +106,7 @@ PanoramiXCreateWindow(ClientPtr client)
     if ((Mask) stuff->mask & CWColormap) {
         cmap_offset = Ones((Mask) stuff->mask & (CWColormap - 1));
         tmp = *((CARD32 *) &stuff[1] + cmap_offset);
-        if ((tmp != CopyFromParent) && (tmp != None)) {
+        if (tmp != CopyFromParent) {
             result = dixLookupResourceByType((void **) &cmap, tmp,
                                              XRT_COLORMAP, client,
                                              DixReadAccess);
@@ -210,7 +210,7 @@ PanoramiXChangeWindowAttributes(ClientPtr client)
     if ((Mask) stuff->valueMask & CWColormap) {
         cmap_offset = Ones((Mask) stuff->valueMask & (CWColormap - 1));
         tmp = *((CARD32 *) &stuff[1] + cmap_offset);
-        if ((tmp != CopyFromParent) && (tmp != None)) {
+        if (tmp != CopyFromParent) {
             result = dixLookupResourceByType((void **) &cmap, tmp,
                                              XRT_COLORMAP, client,
                                              DixReadAccess);
diff --git a/Xext/saver.c b/Xext/saver.c
index 0e20467..750b8b9 100644
--- a/Xext/saver.c
+++ b/Xext/saver.c
@@ -1143,7 +1143,7 @@ ProcScreenSaverSetAttributes(ClientPtr client)
         if ((Mask) stuff->mask & CWColormap) {
             cmap_offset = Ones((Mask) stuff->mask & (CWColormap - 1));
             tmp = *((CARD32 *) &stuff[1] + cmap_offset);
-            if ((tmp != CopyFromParent) && (tmp != None)) {
+            if (tmp != CopyFromParent) {
                 status = dixLookupResourceByType((void **) &cmap, tmp,
                                                  XRT_COLORMAP, client,
                                                  DixReadAccess);
diff --git a/Xi/exevents.c b/Xi/exevents.c
index e728310..52b91e8 100644
--- a/Xi/exevents.c
+++ b/Xi/exevents.c
@@ -1379,6 +1379,9 @@ DeliverTouchEmulatedEvent(DeviceIntPtr dev, TouchPointInfoPtr ti,
     if (!TouchResourceIsOwner(ti, listener->listener))
         return !Success;
 
+    if (!ti->emulate_pointer)
+        return !Success;
+
     nevents = TouchConvertToPointerEvent(ev, &motion, &button);
     BUG_RETURN_VAL(nevents == 0, BadValue);
 
diff --git a/configure.ac b/configure.ac
index 77cf234..cfffcd8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -555,17 +555,27 @@ AC_ARG_WITH(apple-application-name,AS_HELP_STRING([--with-apple-application-name
 				[ APPLE_APPLICATION_NAME="${withval}" ],
 				[ APPLE_APPLICATION_NAME="X11" ])
 AC_SUBST([APPLE_APPLICATION_NAME])
-AC_ARG_WITH(launchd-id-prefix,  AS_HELP_STRING([--with-launchd-id-prefix=PATH], [Deprecated: Use --with-bundle-id-prefix.]),
-                                [ BUNDLE_ID_PREFIX="${withval}" ],
-                                [ BUNDLE_ID_PREFIX="org.x" ])
-AC_ARG_WITH(bundle-id-prefix,  AS_HELP_STRING([--with-bundle-id-prefix=PATH], [Prefix to use for bundle identifiers (default: org.x)]),
+AC_ARG_WITH(bundle-id-prefix,  AS_HELP_STRING([--with-bundle-id-prefix=RDNS_PREFIX], [Prefix to use for bundle identifiers (default: org.x)]),
                                [ BUNDLE_ID_PREFIX="${withval}" ])
 AC_SUBST([BUNDLE_ID_PREFIX])
 AC_DEFINE_UNQUOTED(BUNDLE_ID_PREFIX, "$BUNDLE_ID_PREFIX", [Prefix to use for bundle identifiers])
+m4_define(DEFAULT_BUNDLE_VERSION, m4_esyscmd([echo ]AC_PACKAGE_VERSION[ | cut -f1-3 -d. | tr -d '\n']))
+AC_ARG_WITH(bundle-version,    AS_HELP_STRING([--with-bundle-version=VERSION], [Version to use for X11.app's CFBundleVersion (default: ]DEFAULT_BUNDLE_VERSION[)]),
+                               [ BUNDLE_VERSION="${withval}" ],
+                               [ BUNDLE_VERSION="DEFAULT_BUNDLE_VERSION" ])
+AC_SUBST([BUNDLE_VERSION])
+AC_ARG_WITH(bundle-version-string, AS_HELP_STRING([--with-bundle-version-string=VERSION], [Version to use for X11.app's CFBundleShortVersionString (default: ]AC_PACKAGE_VERSION[)]),
+                               [ BUNDLE_VERSION_STRING="${withval}" ],
+                               [ BUNDLE_VERSION_STRING="${PACKAGE_VERSION}" ])
+AC_SUBST([BUNDLE_VERSION_STRING])
 AC_ARG_ENABLE(sparkle,AS_HELP_STRING([--enable-sparkle], [Enable updating of X11.app using the Sparkle Framework (default: disabled)]),
 				[ XQUARTZ_SPARKLE="${enableval}" ],
 				[ XQUARTZ_SPARKLE="no" ])
 AC_SUBST([XQUARTZ_SPARKLE])
+AC_ARG_WITH(sparkle-feed-url,  AS_HELP_STRING([--with-sparkle-feed-url=URL], [URL for the Sparkle feed (default: https://www.xquartz.org/releases/sparkle/release.xml)]),
+                               [ XQUARTZ_SPARKLE_FEED_URL="${withval}" ],
+                               [ XQUARTZ_SPARKLE_FEED_URL="https://www.xquartz.org/releases/sparkle/release.xml" ])
+AC_SUBST([XQUARTZ_SPARKLE_FEED_URL])
 AC_ARG_ENABLE(visibility,     AS_HELP_STRING([--enable-visibility], [Enable symbol visibility (default: auto)]),
 				[SYMBOL_VISIBILITY=$enableval],
 				[SYMBOL_VISIBILITY=auto])
@@ -880,7 +890,7 @@ if test "x$CONFIG_UDEV" = xyes; then
 	fi
 	SAVE_LIBS=$LIBS
 	SAVE_CFLAGS=$CFLAGS
-	CFLAGS=$UDEV_CFLAGS
+	CFLAGS="$CFLAGS $UDEV_CFLAGS"
 	LIBS=$UDEV_LIBS
 	AC_CHECK_FUNCS([udev_monitor_filter_add_match_tag])
 	AC_CHECK_FUNCS([udev_enumerate_add_match_tag])
@@ -1293,7 +1303,7 @@ fi
 
 if test "x$DRI2" = xyes; then
 	save_CFLAGS=$CFLAGS
-	CFLAGS="$GL_CFLAGS $LIBDRM_CFLAGS"
+	CFLAGS="$CFLAGS $GL_CFLAGS $LIBDRM_CFLAGS"
 	AC_COMPILE_IFELSE([AC_LANG_SOURCE([[#include <GL/gl.h>
 #include <GL/internal/dri_interface.h>
 #ifndef __DRI_DRI2
diff --git a/dix/devices.c b/dix/devices.c
index 9b0c7d2..a532dcf 100644
--- a/dix/devices.c
+++ b/dix/devices.c
@@ -1682,8 +1682,7 @@ ProcSetModifierMapping(ClientPtr client)
                        stuff->numKeyPerModifier);
     if (rc == MappingFailed || rc == -1)
         return BadValue;
-    if (rc != Success && rc != MappingSuccess && rc != MappingFailed &&
-        rc != MappingBusy)
+    if (rc != MappingSuccess && rc != MappingFailed && rc != MappingBusy)
         return rc;
 
     rep.success = rc;
diff --git a/dix/enterleave.c b/dix/enterleave.c
index f0b1572..1b341f2 100644
--- a/dix/enterleave.c
+++ b/dix/enterleave.c
@@ -1446,19 +1446,25 @@ DeviceFocusEvents(DeviceIntPtr dev, WindowPtr from, WindowPtr to, int mode)
 
     if ((to == NullWindow) || (to == PointerRootWin)) {
         if ((from == NullWindow) || (from == PointerRootWin)) {
-            if (from == PointerRootWin)
+            if (from == PointerRootWin) {
+                DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyPointer,
+                                 sprite->win);
                 DeviceFocusOutEvents(dev, sprite->win,
                                      GetCurrentRootWindow(dev), mode,
                                      NotifyPointer);
+            }
             /* Notify all the roots */
             for (i = 0; i < nscreens; i++)
                 DeviceFocusEvent(dev, XI_FocusOut, mode, out,
                                  screenInfo.screens[i]->root);
         }
         else {
-            if (IsParent(from, sprite->win))
+            if (IsParent(from, sprite->win)) {
+                DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyPointer,
+                                 sprite->win);
                 DeviceFocusOutEvents(dev, sprite->win, from, mode,
                                      NotifyPointer);
+            }
             DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyNonlinear, from);
             /* next call catches the root too, if the screen changed */
             DeviceFocusOutEvents(dev, from, NullWindow, mode,
@@ -1476,10 +1482,13 @@ DeviceFocusEvents(DeviceIntPtr dev, WindowPtr from, WindowPtr to, int mode)
     }
     else {
         if ((from == NullWindow) || (from == PointerRootWin)) {
-            if (from == PointerRootWin)
+            if (from == PointerRootWin) {
+                DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyPointer,
+                                 sprite->win);
                 DeviceFocusOutEvents(dev, sprite->win,
                                      GetCurrentRootWindow(dev), mode,
                                      NotifyPointer);
+            }
             for (i = 0; i < nscreens; i++)
                 DeviceFocusEvent(dev, XI_FocusOut, mode, out,
                                  screenInfo.screens[i]->root);
@@ -1506,9 +1515,12 @@ DeviceFocusEvents(DeviceIntPtr dev, WindowPtr from, WindowPtr to, int mode)
                 if ((IsParent(from, sprite->win)) &&
                     (sprite->win != from) &&
                     (!IsParent(to, sprite->win)) &&
-                    (!IsParent(sprite->win, to)))
+                    (!IsParent(sprite->win, to))) {
+                    DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyPointer,
+                                     sprite->win);
                     DeviceFocusOutEvents(dev, sprite->win, from, mode,
                                          NotifyPointer);
+                }
                 DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyInferior, from);
                 DeviceFocusInEvents(dev, from, to, mode, NotifyVirtual);
                 DeviceFocusEvent(dev, XI_FocusIn, mode, NotifyAncestor, to);
diff --git a/dix/ptrveloc.c b/dix/ptrveloc.c
index e75300a..050c12a 100644
--- a/dix/ptrveloc.c
+++ b/dix/ptrveloc.c
@@ -134,13 +134,19 @@ InitPredictableAccelerationScheme(DeviceIntPtr dev,
     scheme = *protoScheme;
     vel = calloc(1, sizeof(DeviceVelocityRec));
     schemeData = calloc(1, sizeof(PredictableAccelSchemeRec));
-    if (!vel || !schemeData)
+    if (!vel || !schemeData) {
+        free(vel);
+        free(schemeData);
         return FALSE;
+    }
     InitVelocityData(vel);
     schemeData->vel = vel;
     scheme.accelData = schemeData;
-    if (!InitializePredictableAccelerationProperties(dev, vel, schemeData))
+    if (!InitializePredictableAccelerationProperties(dev, vel, schemeData)) {
+        free(vel);
+        free(schemeData);
         return FALSE;
+    }
     /* all fine, assign scheme to device */
     dev->valuator->accelScheme = scheme;
     return TRUE;
diff --git a/exa/exa_glyphs.c b/exa/exa_glyphs.c
index cf21ea9..192a643 100644
--- a/exa/exa_glyphs.c
+++ b/exa/exa_glyphs.c
@@ -618,9 +618,9 @@ exaGlyphsToMask(PicturePtr pMask, ExaGlyphBufferPtr buffer)
 }
 
 static void
-exaGlyphsToDst(PicturePtr pSrc, PicturePtr pDst, ExaGlyphBufferPtr buffer)
+exaGlyphsToDst(CARD8 op, PicturePtr pSrc, PicturePtr pDst, ExaGlyphBufferPtr buffer)
 {
-    exaCompositeRects(PictOpOver, pSrc, buffer->mask, pDst, buffer->count,
+    exaCompositeRects(op, pSrc, buffer->mask, pDst, buffer->count,
                       buffer->rects);
 
     buffer->count = 0;
@@ -801,7 +801,7 @@ exaGlyphs(CARD8 op,
                                        0, 0, x - glyph->info.x,
                                        y - glyph->info.y)
                         == ExaGlyphNeedFlush) {
-                        exaGlyphsToDst(pSrc, pDst, &buffer);
+                        exaGlyphsToDst(op, pSrc, pDst, &buffer);
                         exaBufferGlyph(pScreen, &buffer, glyph, pSrc, pDst,
                                        xSrc + (x - glyph->info.x) - first_xOff,
                                        ySrc + (y - glyph->info.y) - first_yOff,
@@ -821,7 +821,7 @@ exaGlyphs(CARD8 op,
         if (maskFormat)
             exaGlyphsToMask(pMask, &buffer);
         else
-            exaGlyphsToDst(pSrc, pDst, &buffer);
+            exaGlyphsToDst(op, pSrc, pDst, &buffer);
     }
 
     if (maskFormat) {
diff --git a/exa/exa_render.c b/exa/exa_render.c
index fc3ddea..b24bec0 100644
--- a/exa/exa_render.c
+++ b/exa/exa_render.c
@@ -1141,7 +1141,8 @@ exaTrapezoids(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
 
         exaPrepareAccess(pPicture->pDrawable, EXA_PREPARE_DEST);
         for (; ntrap; ntrap--, traps++)
-            (*ps->RasterizeTrapezoid) (pPicture, traps, -bounds.x1, -bounds.y1);
+            if (xTrapezoidValid(traps))
+                (*ps->RasterizeTrapezoid) (pPicture, traps, -bounds.x1, -bounds.y1);
         exaFinishAccess(pPicture->pDrawable, EXA_PREPARE_DEST);
 
         xRel = bounds.x1 + xSrc - xDst;
diff --git a/glamor/glamor.c b/glamor/glamor.c
index 9c6a0d1..0cb73c4 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -140,6 +140,42 @@ glamor_get_pixmap_texture(PixmapPtr pixmap)
     return pixmap_priv->fbo->tex;
 }
 
+void
+glamor_bind_texture(glamor_screen_private *glamor_priv, GLenum texture,
+                    glamor_pixmap_fbo *fbo, Bool destination_red)
+{
+    glActiveTexture(texture);
+    glBindTexture(GL_TEXTURE_2D, fbo->tex);
+
+    /* If we're pulling data from a GL_RED texture, then whether we
+     * want to make it an A,0,0,0 result or a 0,0,0,R result depends
+     * on whether the destination is also a GL_RED texture.
+     *
+     * For GL_RED destinations, we need to leave the bits in the R
+     * channel. For all other destinations, we need to clear out the R
+     * channel so that it returns zero for R, G and B.
+     *
+     * Note that we're leaving the SWIZZLE_A value alone; for GL_RED
+     * destinations, that means we'll actually be returning R,0,0,R,
+     * but it doesn't matter as the bits in the alpha channel aren't
+     * going anywhere.
+     */
+
+    /* Is the operand a GL_RED fbo?
+     */
+
+    if (glamor_fbo_red_is_alpha(glamor_priv, fbo)) {
+
+        /* If destination is also GL_RED, then preserve the bits in
+         * the R channel */
+
+        if (destination_red)
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_R, GL_RED);
+        else
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_R, GL_ZERO);
+    }
+}
+
 PixmapPtr
 glamor_create_pixmap(ScreenPtr screen, int w, int h, int depth,
                      unsigned int usage)
@@ -816,3 +852,12 @@ glamor_name_from_pixmap(PixmapPtr pixmap, CARD16 *stride, CARD32 *size)
     }
     return -1;
 }
+
+void
+glamor_finish(ScreenPtr screen)
+{
+    glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
+
+    glamor_make_current(glamor_priv);
+    glFinish();
+}
diff --git a/glamor/glamor.h b/glamor/glamor.h
index 0aa6d56..250dc83 100644
--- a/glamor/glamor.h
+++ b/glamor/glamor.h
@@ -342,6 +342,7 @@ extern _X_EXPORT void glamor_destroy_gc(GCPtr gc);
 extern Bool _X_EXPORT glamor_change_window_attributes(WindowPtr pWin, unsigned long mask);
 extern void _X_EXPORT glamor_copy_window(WindowPtr window, DDXPointRec old_origin, RegionPtr src_region);
 
+extern _X_EXPORT void glamor_finish(ScreenPtr screen);
 #define HAS_GLAMOR_TEXT 1
 
 #ifdef GLAMOR_FOR_XORG
diff --git a/glamor/glamor_composite_glyphs.c b/glamor/glamor_composite_glyphs.c
index f51ff6d..cc0aa6f 100644
--- a/glamor/glamor_composite_glyphs.c
+++ b/glamor/glamor_composite_glyphs.c
@@ -246,8 +246,7 @@ glamor_glyphs_flush(CARD8 op, PicturePtr src, PicturePtr dst,
     glamor_put_vbo_space(drawable->pScreen);
 
     glEnable(GL_SCISSOR_TEST);
-    glActiveTexture(GL_TEXTURE1);
-    glBindTexture(GL_TEXTURE_2D, atlas_fbo->tex);
+    glamor_bind_texture(glamor_priv, GL_TEXTURE1, atlas_fbo, FALSE);
 
     for (;;) {
         if (!glamor_use_program_render(prog, op, src, dst))
@@ -558,7 +557,7 @@ glamor_free_glyph_atlas(struct glamor_glyph_atlas *atlas)
     if (!atlas)
         return;
     if (atlas->atlas)
-        FreePicture(atlas->atlas, 0);
+        (*atlas->atlas->drawable.pScreen->DestroyPixmap)(atlas->atlas);
     free (atlas);
 }
 
diff --git a/glamor/glamor_compositerects.c b/glamor/glamor_compositerects.c
index 885a6c0..199e627 100644
--- a/glamor/glamor_compositerects.c
+++ b/glamor/glamor_compositerects.c
@@ -107,7 +107,6 @@ glamor_composite_rectangles(CARD8 op,
     struct glamor_pixmap_private *priv;
     pixman_region16_t region;
     pixman_box16_t *boxes;
-    int dst_x, dst_y;
     int num_boxes;
     PicturePtr source = NULL;
     Bool need_free_region = FALSE;
@@ -225,17 +224,18 @@ glamor_composite_rectangles(CARD8 op,
            RegionExtents(&region)->x2, RegionExtents(&region)->y2,
            RegionNumRects(&region));
 
-    glamor_get_drawable_deltas(dst->pDrawable, pixmap, &dst_x, &dst_y);
-    pixman_region_translate(&region, dst_x, dst_y);
-
-    DEBUGF("%s: pixmap +(%d, %d) extents (%d, %d),(%d, %d)\n",
-           __FUNCTION__, dst_x, dst_y,
-           RegionExtents(&region)->x1, RegionExtents(&region)->y1,
-           RegionExtents(&region)->x2, RegionExtents(&region)->y2);
-
     boxes = pixman_region_rectangles(&region, &num_boxes);
     if (op == PictOpSrc || op == PictOpClear) {
         CARD32 pixel;
+        int dst_x, dst_y;
+
+        glamor_get_drawable_deltas(dst->pDrawable, pixmap, &dst_x, &dst_y);
+        pixman_region_translate(&region, dst_x, dst_y);
+
+        DEBUGF("%s: pixmap +(%d, %d) extents (%d, %d),(%d, %d)\n",
+               __FUNCTION__, dst_x, dst_y,
+               RegionExtents(&region)->x1, RegionExtents(&region)->y1,
+               RegionExtents(&region)->x2, RegionExtents(&region)->y2);
 
         if (op == PictOpClear)
             pixel = 0;
diff --git a/glamor/glamor_copy.c b/glamor/glamor_copy.c
index 5fed89f..3501a0d 100644
--- a/glamor/glamor_copy.c
+++ b/glamor/glamor_copy.c
@@ -38,8 +38,8 @@ use_copyarea(PixmapPtr dst, GCPtr gc, glamor_program *prog, void *arg)
     struct copy_args *args = arg;
     glamor_pixmap_fbo *src = args->src;
 
-    glActiveTexture(GL_TEXTURE0);
-    glBindTexture(GL_TEXTURE_2D, src->tex);
+    glamor_bind_texture(glamor_get_screen_private(dst->drawable.pScreen),
+                        GL_TEXTURE0, src, TRUE);
 
     glUniform2f(prog->fill_offset_uniform, args->dx, args->dy);
     glUniform2f(prog->fill_size_inv_uniform, 1.0f/src->width, 1.0f/src->height);
@@ -67,8 +67,8 @@ use_copyplane(PixmapPtr dst, GCPtr gc, glamor_program *prog, void *arg)
     struct copy_args *args = arg;
     glamor_pixmap_fbo *src = args->src;
 
-    glActiveTexture(GL_TEXTURE0);
-    glBindTexture(GL_TEXTURE_2D, src->tex);
+    glamor_bind_texture(glamor_get_screen_private(dst->drawable.pScreen),
+                        GL_TEXTURE0, src, TRUE);
 
     glUniform2f(prog->fill_offset_uniform, args->dx, args->dy);
     glUniform2f(prog->fill_size_inv_uniform, 1.0f/src->width, 1.0f/src->height);
diff --git a/glamor/glamor_dash.c b/glamor/glamor_dash.c
index a6a11c1..3c19dba 100644
--- a/glamor/glamor_dash.c
+++ b/glamor/glamor_dash.c
@@ -188,8 +188,7 @@ glamor_dash_setup(DrawablePtr drawable, GCPtr gc)
 
     /* Set the dash pattern as texture 1 */
 
-    glActiveTexture(GL_TEXTURE1);
-    glBindTexture(GL_TEXTURE_2D, dash_priv->fbo->tex);
+    glamor_bind_texture(glamor_priv, GL_TEXTURE1, dash_priv->fbo, FALSE);
     glUniform1i(prog->dash_uniform, 1);
     glUniform1f(prog->dash_length_uniform, dash_pixmap->drawable.width);
 
diff --git a/glamor/glamor_egl.c b/glamor/glamor_egl.c
index 80a97f7..5aacbed 100644
--- a/glamor/glamor_egl.c
+++ b/glamor/glamor_egl.c
@@ -823,11 +823,6 @@ glamor_egl_init(ScrnInfoPtr scrn, int fd)
 
     glamor_egl->has_gem = glamor_egl_check_has_gem(fd);
 
-#ifndef GLAMOR_GLES2
-    eglBindAPI(EGL_OPENGL_API);
-#else
-    eglBindAPI(EGL_OPENGL_ES_API);
-#endif
     if (!eglInitialize
         (glamor_egl->display, &glamor_egl->major, &glamor_egl->minor)) {
         xf86DrvMsg(scrn->scrnIndex, X_ERROR, "eglInitialize() failed\n");
@@ -835,6 +830,12 @@ glamor_egl_init(ScrnInfoPtr scrn, int fd)
         goto error;
     }
 
+#ifndef GLAMOR_GLES2
+    eglBindAPI(EGL_OPENGL_API);
+#else
+    eglBindAPI(EGL_OPENGL_ES_API);
+#endif
+
     version = eglQueryString(glamor_egl->display, EGL_VERSION);
     xf86Msg(X_INFO, "%s: EGL version %s:\n", glamor_name, version);
 
diff --git a/glamor/glamor_fbo.c b/glamor/glamor_fbo.c
index c6ba095..5bfffe5 100644
--- a/glamor/glamor_fbo.c
+++ b/glamor/glamor_fbo.c
@@ -340,10 +340,8 @@ _glamor_create_tex(glamor_screen_private *glamor_priv,
     glBindTexture(GL_TEXTURE_2D, tex);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-    if (format == glamor_priv->one_channel_format && format == GL_RED) {
-        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_R, GL_ZERO);
+    if (format == glamor_priv->one_channel_format && format == GL_RED)
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_A, GL_RED);
-    }
     glamor_priv->suppress_gl_out_of_memory_logging = true;
     glTexImage2D(GL_TEXTURE_2D, 0, format, w, h, 0,
                  format, GL_UNSIGNED_BYTE, NULL);
diff --git a/glamor/glamor_priv.h b/glamor/glamor_priv.h
index a70f10e..9d40397 100644
--- a/glamor/glamor_priv.h
+++ b/glamor/glamor_priv.h
@@ -593,6 +593,34 @@ void glamor_fini_pixmap_fbo(ScreenPtr screen);
 Bool glamor_pixmap_fbo_fixup(ScreenPtr screen, PixmapPtr pixmap);
 void glamor_fbo_expire(glamor_screen_private *glamor_priv);
 
+/* Return whether 'picture' is alpha-only */
+static inline Bool glamor_picture_is_alpha(PicturePtr picture)
+{
+    return picture->format == PICT_a1 || picture->format == PICT_a8;
+}
+
+/* Return whether 'fbo' is storing alpha bits in the red channel */
+static inline Bool
+glamor_fbo_red_is_alpha(glamor_screen_private *glamor_priv, glamor_pixmap_fbo *fbo)
+{
+    /* True when the format is GL_RED (that can only happen when our one channel format is GL_RED */
+    return fbo->format == GL_RED;
+}
+
+/* Return whether 'picture' is storing alpha bits in the red channel */
+static inline Bool
+glamor_picture_red_is_alpha(PicturePtr picture)
+{
+    /* True when the picture is alpha only and the screen is using GL_RED for alpha pictures */
+    return glamor_picture_is_alpha(picture) &&
+        glamor_get_screen_private(picture->pDrawable->pScreen)->one_channel_format == GL_RED;
+}
+
+void glamor_bind_texture(glamor_screen_private *glamor_priv,
+                         GLenum texture,
+                         glamor_pixmap_fbo *fbo,
+                         Bool destination_red);
+
 glamor_pixmap_fbo *glamor_create_fbo_array(glamor_screen_private *glamor_priv,
                                            int w, int h, GLenum format,
                                            int flag, int block_w, int block_h,
diff --git a/glamor/glamor_program.c b/glamor/glamor_program.c
index 0a94de6..dec116c 100644
--- a/glamor/glamor_program.c
+++ b/glamor/glamor_program.c
@@ -445,6 +445,7 @@ static struct blendinfo composite_op_info[] = {
 static void
 glamor_set_blend(CARD8 op, glamor_program_alpha alpha, PicturePtr dst)
 {
+    glamor_screen_private *glamor_priv = glamor_get_screen_private(dst->pDrawable->pScreen);
     GLenum src_blend, dst_blend;
     struct blendinfo *op_info;
 
@@ -459,6 +460,9 @@ glamor_set_blend(CARD8 op, glamor_program_alpha alpha, PicturePtr dst)
         break;
     }
 
+    if (glamor_priv->gl_flavor != GLAMOR_GL_ES2)
+        glDisable(GL_COLOR_LOGIC_OP);
+
     if (op == PictOpSrc)
         return;
 
@@ -527,6 +531,7 @@ use_source_picture(CARD8 op, PicturePtr src, PicturePtr dst, glamor_program *pro
     glamor_set_blend(op, prog->alpha, dst);
 
     return glamor_set_texture((PixmapPtr) src->pDrawable,
+                              glamor_picture_red_is_alpha(dst),
                               0, 0,
                               prog->fill_offset_uniform,
                               prog->fill_size_inv_uniform);
@@ -545,7 +550,8 @@ use_source_1x1_picture(CARD8 op, PicturePtr src, PicturePtr dst, glamor_program
 {
     glamor_set_blend(op, prog->alpha, dst);
 
-    return glamor_set_texture_pixmap((PixmapPtr) src->pDrawable);
+    return glamor_set_texture_pixmap((PixmapPtr) src->pDrawable,
+                                     glamor_picture_red_is_alpha(dst));
 }
 
 static const glamor_facet glamor_source_1x1_picture = {
diff --git a/glamor/glamor_render.c b/glamor/glamor_render.c
index 73ac831..d70316d 100644
--- a/glamor/glamor_render.c
+++ b/glamor/glamor_render.c
@@ -105,7 +105,7 @@ glamor_create_composite_fs(struct shader_key *key)
     /* The texture and the pixmap size is not match eaxctly, so can't sample it directly.
      * rel_sampler will recalculate the texture coords.*/
     const char *rel_sampler =
-        " vec4 rel_sampler(sampler2D tex_image, vec2 tex, vec4 wh, int repeat)\n"
+        " vec4 rel_sampler_rgba(sampler2D tex_image, vec2 tex, vec4 wh, int repeat)\n"
         "{\n"
         "	if (repeat >= RepeatFix) {\n"
         "		tex = rel_tex_coord(tex, wh, repeat);\n"
@@ -117,6 +117,19 @@ glamor_create_composite_fs(struct shader_key *key)
         "		}\n"
         "	}\n"
         "	return texture2D(tex_image, tex);\n"
+        "}\n"
+        " vec4 rel_sampler_rgbx(sampler2D tex_image, vec2 tex, vec4 wh, int repeat)\n"
+        "{\n"
+        "	if (repeat >= RepeatFix) {\n"
+        "		tex = rel_tex_coord(tex, wh, repeat);\n"
+        "		if (repeat == RepeatFix + RepeatNone) {\n"
+        "			if (tex.x < 0.0 || tex.x >= 1.0 || \n"
+        "			    tex.y < 0.0 || tex.y >= 1.0)\n"
+        "				return vec4(0.0, 0.0, 0.0, 0.0);\n"
+        "			tex = (fract(tex) / wh.xy);\n"
+        "		}\n"
+        "	}\n"
+        "	return vec4(texture2D(tex_image, tex).rgb, 1.0);\n"
         "}\n";
 
     const char *source_solid_fetch =
@@ -131,8 +144,8 @@ glamor_create_composite_fs(struct shader_key *key)
         "uniform vec4 source_wh;"
         "vec4 get_source()\n"
         "{\n"
-        "	return rel_sampler(source_sampler, source_texture,\n"
-        "			   source_wh, source_repeat_mode);\n"
+        "	return rel_sampler_rgba(source_sampler, source_texture,\n"
+        "			        source_wh, source_repeat_mode);\n"
         "}\n";
     const char *source_pixmap_fetch =
         "varying vec2 source_texture;\n"
@@ -140,9 +153,8 @@ glamor_create_composite_fs(struct shader_key *key)
         "uniform vec4 source_wh;\n"
         "vec4 get_source()\n"
         "{\n"
-        "	return vec4(rel_sampler(source_sampler, source_texture,\n"
-        "				source_wh, source_repeat_mode).rgb,\n"
-        "				1.0);\n"
+        "	return rel_sampler_rgbx(source_sampler, source_texture,\n"
+        "				source_wh, source_repeat_mode);\n"
         "}\n";
     const char *mask_none =
         "vec4 get_mask()\n"
@@ -161,8 +173,8 @@ glamor_create_composite_fs(struct shader_key *key)
         "uniform vec4 mask_wh;\n"
         "vec4 get_mask()\n"
         "{\n"
-        "	return rel_sampler(mask_sampler, mask_texture,\n"
-        "			   mask_wh, mask_repeat_mode);\n"
+        "	return rel_sampler_rgba(mask_sampler, mask_texture,\n"
+        "			        mask_wh, mask_repeat_mode);\n"
         "}\n";
     const char *mask_pixmap_fetch =
         "varying vec2 mask_texture;\n"
@@ -170,8 +182,8 @@ glamor_create_composite_fs(struct shader_key *key)
         "uniform vec4 mask_wh;\n"
         "vec4 get_mask()\n"
         "{\n"
-        "	return vec4(rel_sampler(mask_sampler, mask_texture,\n"
-        "				mask_wh, mask_repeat_mode).rgb, 1.0);\n"
+        "	return rel_sampler_rgbx(mask_sampler, mask_texture,\n"
+        "				mask_wh, mask_repeat_mode);\n"
         "}\n";
 
     const char *dest_swizzle_default =
@@ -500,15 +512,24 @@ static void
 glamor_set_composite_texture(glamor_screen_private *glamor_priv, int unit,
                              PicturePtr picture,
                              PixmapPtr pixmap,
-                             GLuint wh_location, GLuint repeat_location)
+                             GLuint wh_location, GLuint repeat_location,
+                             glamor_pixmap_private *dest_priv)
 {
     glamor_pixmap_private *pixmap_priv = glamor_get_pixmap_private(pixmap);
+    glamor_pixmap_fbo *fbo = pixmap_priv->fbo;
     float wh[4];
     int repeat_type;
 
     glamor_make_current(glamor_priv);
-    glActiveTexture(GL_TEXTURE0 + unit);
-    glBindTexture(GL_TEXTURE_2D, pixmap_priv->fbo->tex);
+
+    /* The red channel swizzling doesn't depend on whether we're using
+     * 'fbo' as source or mask as we must have the same answer in case
+     * the same fbo is being used for both. That means the mask
+     * channel will sometimes get red bits in the R channel, and
+     * sometimes get zero bits in the R channel, which is harmless.
+     */
+    glamor_bind_texture(glamor_priv, GL_TEXTURE0 + unit, fbo,
+                        glamor_fbo_red_is_alpha(glamor_priv, dest_priv->fbo));
     repeat_type = picture->repeatType;
     switch (picture->repeatType) {
     case RepeatNone:
@@ -557,8 +578,8 @@ glamor_set_composite_texture(glamor_screen_private *glamor_priv, int unit,
      *
      **/
     if (glamor_pixmap_priv_is_large(pixmap_priv) ||
-        (glamor_priv->gl_flavor == GLAMOR_GL_ES2 && repeat_type == RepeatNone &&
-         picture->transform)) {
+        ((!PICT_FORMAT_A(picture->format) || glamor_priv->gl_flavor == GLAMOR_GL_ES2) &&
+         repeat_type == RepeatNone && picture->transform)) {
         glamor_pixmap_fbo_fix_wh_ratio(wh, pixmap, pixmap_priv);
         glUniform4fv(wh_location, 1, wh);
 
@@ -1068,7 +1089,8 @@ glamor_composite_set_shader_blend(glamor_screen_private *glamor_priv,
         glamor_set_composite_texture(glamor_priv, 0,
                                      shader->source,
                                      shader->source_pixmap, shader->source_wh,
-                                     shader->source_repeat_mode);
+                                     shader->source_repeat_mode,
+                                     dest_priv);
     }
 
     if (key->mask != SHADER_MASK_NONE) {
@@ -1080,10 +1102,14 @@ glamor_composite_set_shader_blend(glamor_screen_private *glamor_priv,
             glamor_set_composite_texture(glamor_priv, 1,
                                          shader->mask,
                                          shader->mask_pixmap, shader->mask_wh,
-                                         shader->mask_repeat_mode);
+                                         shader->mask_repeat_mode,
+                                         dest_priv);
         }
     }
 
+    if (glamor_priv->gl_flavor != GLAMOR_GL_ES2)
+        glDisable(GL_COLOR_LOGIC_OP);
+
     if (op_info->source_blend == GL_ONE && op_info->dest_blend == GL_ZERO) {
         glDisable(GL_BLEND);
     }
@@ -1144,12 +1170,12 @@ glamor_composite_with_shader(CARD8 op,
         }
     }
 
+    glamor_make_current(glamor_priv);
+
     glamor_set_destination_pixmap_priv_nc(glamor_priv, dest_pixmap, dest_pixmap_priv);
     glamor_composite_set_shader_blend(glamor_priv, dest_pixmap_priv, &key, shader, &op_info);
     glamor_set_alu(screen, GXcopy);
 
-    glamor_make_current(glamor_priv);
-
     glamor_priv->has_source_coords = key.source != SHADER_SOURCE_SOLID;
     glamor_priv->has_mask_coords = (key.mask != SHADER_MASK_NONE &&
                                     key.mask != SHADER_MASK_SOLID);
@@ -1392,6 +1418,36 @@ glamor_composite_clipped_region(CARD8 op,
     DEBUGF("clipped (%d %d) (%d %d) (%d %d) width %d height %d \n",
            x_source, y_source, x_mask, y_mask, x_dest, y_dest, width, height);
 
+    /* Is the composite operation equivalent to a copy? */
+    if (!mask && !source->alphaMap && !dest->alphaMap
+        && source->pDrawable && !source->transform
+        && ((op == PictOpSrc
+             && (source->format == dest->format
+                 || (PICT_FORMAT_COLOR(dest->format)
+                     && PICT_FORMAT_COLOR(source->format)
+                     && dest->format == PICT_FORMAT(PICT_FORMAT_BPP(source->format),
+                                                    PICT_FORMAT_TYPE(source->format),
+                                                    0,
+                                                    PICT_FORMAT_R(source->format),
+                                                    PICT_FORMAT_G(source->format),
+                                                    PICT_FORMAT_B(source->format)))))
+            || (op == PictOpOver
+                && source->format == dest->format
+                && !PICT_FORMAT_A(source->format)))
+        && x_source >= 0 && y_source >= 0
+        && (x_source + width) <= source->pDrawable->width
+        && (y_source + height) <= source->pDrawable->height) {
+        x_source += source->pDrawable->x;
+        y_source += source->pDrawable->y;
+        x_dest += dest->pDrawable->x;
+        y_dest += dest->pDrawable->y;
+        glamor_copy(source->pDrawable, dest->pDrawable, NULL,
+                    box, nbox, x_source - x_dest,
+                    y_source - y_dest, FALSE, FALSE, 0, NULL);
+        ok = TRUE;
+        goto out;
+    }
+
     /* XXX is it possible source mask have non-zero drawable.x/y? */
     if (source
         && ((!source->pDrawable
diff --git a/glamor/glamor_spans.c b/glamor/glamor_spans.c
index 89a9c51..5217d04 100644
--- a/glamor/glamor_spans.c
+++ b/glamor/glamor_spans.c
@@ -294,8 +294,7 @@ glamor_set_spans_gl(DrawablePtr drawable, GCPtr gc, char *src,
         BoxPtr              box = glamor_pixmap_box_at(pixmap_priv, box_index);
         glamor_pixmap_fbo  *fbo = glamor_pixmap_fbo_at(pixmap_priv, box_index);
 
-        glActiveTexture(GL_TEXTURE0);
-        glBindTexture(GL_TEXTURE_2D, fbo->tex);
+        glamor_bind_texture(glamor_priv, GL_TEXTURE0, fbo, TRUE);
 
         s = src;
         for (n = 0; n < numPoints; n++) {
diff --git a/glamor/glamor_transfer.c b/glamor/glamor_transfer.c
index ed81195..d788d06 100644
--- a/glamor/glamor_transfer.c
+++ b/glamor/glamor_transfer.c
@@ -83,8 +83,7 @@ glamor_upload_boxes(PixmapPtr pixmap, BoxPtr in_boxes, int in_nbox,
         BoxPtr                  boxes = in_boxes;
         int                     nbox = in_nbox;
 
-        glActiveTexture(GL_TEXTURE0);
-        glBindTexture(GL_TEXTURE_2D, fbo->tex);
+        glamor_bind_texture(glamor_priv, GL_TEXTURE0, fbo, TRUE);
 
         while (nbox--) {
 
diff --git a/glamor/glamor_transform.c b/glamor/glamor_transform.c
index fc96fd6..eff500c 100644
--- a/glamor/glamor_transform.c
+++ b/glamor/glamor_transform.c
@@ -158,7 +158,7 @@ glamor_set_solid(PixmapPtr      pixmap,
 }
 
 Bool
-glamor_set_texture_pixmap(PixmapPtr texture)
+glamor_set_texture_pixmap(PixmapPtr texture, Bool destination_red)
 {
     glamor_pixmap_private *texture_priv;
 
@@ -170,8 +170,9 @@ glamor_set_texture_pixmap(PixmapPtr texture)
     if (glamor_pixmap_priv_is_large(texture_priv))
         return FALSE;
 
-    glActiveTexture(GL_TEXTURE0);
-    glBindTexture(GL_TEXTURE_2D, texture_priv->fbo->tex);
+    glamor_bind_texture(glamor_get_screen_private(texture->drawable.pScreen),
+                        GL_TEXTURE0,
+                        texture_priv->fbo, destination_red);
 
     /* we're not setting the sampler uniform here as we always use
      * GL_TEXTURE0, and the default value for uniforms is zero. So,
@@ -182,12 +183,13 @@ glamor_set_texture_pixmap(PixmapPtr texture)
 
 Bool
 glamor_set_texture(PixmapPtr    texture,
+                   Bool         destination_red,
                    int          off_x,
                    int          off_y,
                    GLint        offset_uniform,
                    GLint        size_inv_uniform)
 {
-    if (!glamor_set_texture_pixmap(texture))
+    if (!glamor_set_texture_pixmap(texture, destination_red))
         return FALSE;
 
     glUniform2f(offset_uniform, off_x, off_y);
@@ -208,6 +210,7 @@ glamor_set_tiled(PixmapPtr      pixmap,
         return FALSE;
 
     return glamor_set_texture(gc->tile.pixmap,
+                              TRUE,
                               -gc->patOrg.x,
                               -gc->patOrg.y,
                               offset_uniform,
@@ -289,6 +292,7 @@ glamor_set_stippled(PixmapPtr      pixmap,
         return FALSE;
 
     return glamor_set_texture(stipple,
+                              FALSE,
                               -gc->patOrg.x,
                               -gc->patOrg.y,
                               offset_uniform,
diff --git a/glamor/glamor_transform.h b/glamor/glamor_transform.h
index 5a520eb..70d2c16 100644
--- a/glamor/glamor_transform.h
+++ b/glamor/glamor_transform.h
@@ -48,10 +48,12 @@ glamor_set_color(PixmapPtr      pixmap,
 }
 
 Bool
-glamor_set_texture_pixmap(PixmapPtr    texture);
+glamor_set_texture_pixmap(PixmapPtr     texture,
+                          Bool          destination_red);
 
 Bool
 glamor_set_texture(PixmapPtr    texture,
+                   Bool         destination_red,
                    int          off_x,
                    int          off_y,
                    GLint        offset_uniform,
diff --git a/glx/glxext.c b/glx/glxext.c
index e41b881..c201fba 100644
--- a/glx/glxext.c
+++ b/glx/glxext.c
@@ -469,6 +469,12 @@ __glXForceCurrent(__GLXclientState * cl, GLXContextTag tag, int *error)
 
     /* Make this context the current one for the GL. */
     if (!cx->isDirect) {
+        /*
+         * If it is being forced, it means that this context was already made
+         * current. So it cannot just be made current again without decrementing
+         * refcount's
+         */
+        (*cx->loseCurrent) (cx);
         lastGLContext = cx;
         if (!(*cx->makeCurrent) (cx)) {
             /* Bind failed, and set the error code.  Bummer */
diff --git a/hw/kdrive/linux/keyboard.c b/hw/kdrive/linux/keyboard.c
index 9a6ee2d..5d31b7d 100644
--- a/hw/kdrive/linux/keyboard.c
+++ b/hw/kdrive/linux/keyboard.c
@@ -43,445 +43,6 @@
 
 extern int LinuxConsoleFd;
 
-static const KeySym linux_to_x[256] = {
-    NoSymbol, NoSymbol, NoSymbol, NoSymbol,
-    NoSymbol, NoSymbol, NoSymbol, NoSymbol,
-    XK_BackSpace, XK_Tab, XK_Linefeed, NoSymbol,
-    NoSymbol, NoSymbol, NoSymbol, NoSymbol,
-    NoSymbol, NoSymbol, NoSymbol, NoSymbol,
-    NoSymbol, NoSymbol, NoSymbol, NoSymbol,
-    NoSymbol, NoSymbol, NoSymbol, XK_Escape,
-    NoSymbol, NoSymbol, NoSymbol, NoSymbol,
-    XK_space, XK_exclam, XK_quotedbl, XK_numbersign,
-    XK_dollar, XK_percent, XK_ampersand, XK_apostrophe,
-    XK_parenleft, XK_parenright, XK_asterisk, XK_plus,
-    XK_comma, XK_minus, XK_period, XK_slash,
-    XK_0, XK_1, XK_2, XK_3,
-    XK_4, XK_5, XK_6, XK_7,
-    XK_8, XK_9, XK_colon, XK_semicolon,
-    XK_less, XK_equal, XK_greater, XK_question,
-    XK_at, XK_A, XK_B, XK_C,
-    XK_D, XK_E, XK_F, XK_G,
-    XK_H, XK_I, XK_J, XK_K,
-    XK_L, XK_M, XK_N, XK_O,
-    XK_P, XK_Q, XK_R, XK_S,
-    XK_T, XK_U, XK_V, XK_W,
-    XK_X, XK_Y, XK_Z, XK_bracketleft,
-    XK_backslash, XK_bracketright, XK_asciicircum, XK_underscore,
-    XK_grave, XK_a, XK_b, XK_c,
-    XK_d, XK_e, XK_f, XK_g,
-    XK_h, XK_i, XK_j, XK_k,
-    XK_l, XK_m, XK_n, XK_o,
-    XK_p, XK_q, XK_r, XK_s,
-    XK_t, XK_u, XK_v, XK_w,
-    XK_x, XK_y, XK_z, XK_braceleft,
-    XK_bar, XK_braceright, XK_asciitilde, XK_BackSpace,
-    NoSymbol, NoSymbol, NoSymbol, NoSymbol,
-    NoSymbol, NoSymbol, NoSymbol, NoSymbol,
-    NoSymbol, NoSymbol, NoSymbol, NoSymbol,
-    NoSymbol, NoSymbol, NoSymbol, NoSymbol,
-    NoSymbol, NoSymbol, NoSymbol, NoSymbol,
-    NoSymbol, NoSymbol, NoSymbol, NoSymbol,
-    NoSymbol, NoSymbol, NoSymbol, NoSymbol,
-    NoSymbol, NoSymbol, NoSymbol, NoSymbol,
-    XK_nobreakspace, XK_exclamdown, XK_cent, XK_sterling,
-    XK_currency, XK_yen, XK_brokenbar, XK_section,
-    XK_diaeresis, XK_copyright, XK_ordfeminine, XK_guillemotleft,
-    XK_notsign, XK_hyphen, XK_registered, XK_macron,
-    XK_degree, XK_plusminus, XK_twosuperior, XK_threesuperior,
-    XK_acute, XK_mu, XK_paragraph, XK_periodcentered,
-    XK_cedilla, XK_onesuperior, XK_masculine, XK_guillemotright,
-    XK_onequarter, XK_onehalf, XK_threequarters, XK_questiondown,
-    XK_Agrave, XK_Aacute, XK_Acircumflex, XK_Atilde,
-    XK_Adiaeresis, XK_Aring, XK_AE, XK_Ccedilla,
-    XK_Egrave, XK_Eacute, XK_Ecircumflex, XK_Ediaeresis,
-    XK_Igrave, XK_Iacute, XK_Icircumflex, XK_Idiaeresis,
-    XK_ETH, XK_Ntilde, XK_Ograve, XK_Oacute,
-    XK_Ocircumflex, XK_Otilde, XK_Odiaeresis, XK_multiply,
-    XK_Ooblique, XK_Ugrave, XK_Uacute, XK_Ucircumflex,
-    XK_Udiaeresis, XK_Yacute, XK_THORN, XK_ssharp,
-    XK_agrave, XK_aacute, XK_acircumflex, XK_atilde,
-    XK_adiaeresis, XK_aring, XK_ae, XK_ccedilla,
-    XK_egrave, XK_eacute, XK_ecircumflex, XK_ediaeresis,
-    XK_igrave, XK_iacute, XK_icircumflex, XK_idiaeresis,
-    XK_eth, XK_ntilde, XK_ograve, XK_oacute,
-    XK_ocircumflex, XK_otilde, XK_odiaeresis, XK_division,
-    XK_oslash, XK_ugrave, XK_uacute, XK_ucircumflex,
-    XK_udiaeresis, XK_yacute, XK_thorn, XK_ydiaeresis
-};
-
-/*
- * Getting a keycode from scancode
- *
- * With XKB
- * --------
- *
- * We have to enqueue keyboard events using standard X keycodes which correspond
- * to AT scancode + 8; this means that we need to translate the Linux scancode
- * provided by the kernel to an AT scancode -- this translation is not linear
- * and requires that we use a LUT.
- *
- *
- * Without XKB
- * -----------
- *
- * We can use custom keycodes, which makes things simpler; we define our custom
- * keycodes as Linux scancodes + KD_KEY_OFFSET
-*/
-
-/*
-   This LUT translates AT scancodes into Linux ones -- the keymap we create
-   for the core X keyboard protocol has to be AT-scancode based so that it
-   corresponds to the Xkb keymap.
-*/
-#if 0
-static unsigned char at2lnx[] = {
-    0x0,                        /* no valid scancode */
-    0x01, /* KEY_Escape */ 0x02,        /* KEY_1 */
-    0x03, /* KEY_2 */ 0x04,     /* KEY_3 */
-    0x05, /* KEY_4 */ 0x06,     /* KEY_5 */
-    0x07, /* KEY_6 */ 0x08,     /* KEY_7 */
-    0x09, /* KEY_8 */ 0x0a,     /* KEY_9 */
-    0x0b, /* KEY_0 */ 0x0c,     /* KEY_Minus */
-    0x0d, /* KEY_Equal */ 0x0e, /* KEY_BackSpace */
-    0x0f, /* KEY_Tab */ 0x10,   /* KEY_Q */
-    0x11, /* KEY_W */ 0x12,     /* KEY_E */
-    0x13, /* KEY_R */ 0x14,     /* KEY_T */
-    0x15, /* KEY_Y */ 0x16,     /* KEY_U */
-    0x17, /* KEY_I */ 0x18,     /* KEY_O */
-    0x19, /* KEY_P */ 0x1a,     /* KEY_LBrace */
-    0x1b, /* KEY_RBrace */ 0x1c,        /* KEY_Enter */
-    0x1d, /* KEY_LCtrl */ 0x1e, /* KEY_A */
-    0x1f, /* KEY_S */ 0x20,     /* KEY_D */
-    0x21, /* KEY_F */ 0x22,     /* KEY_G */
-    0x23, /* KEY_H */ 0x24,     /* KEY_J */
-    0x25, /* KEY_K */ 0x26,     /* KEY_L */
-    0x27, /* KEY_SemiColon */ 0x28,     /* KEY_Quote */
-    0x29, /* KEY_Tilde */ 0x2a, /* KEY_ShiftL */
-    0x2b, /* KEY_BSlash */ 0x2c,        /* KEY_Z */
-    0x2d, /* KEY_X */ 0x2e,     /* KEY_C */
-    0x2f, /* KEY_V */ 0x30,     /* KEY_B */
-    0x31, /* KEY_N */ 0x32,     /* KEY_M */
-    0x33, /* KEY_Comma */ 0x34, /* KEY_Period */
-    0x35, /* KEY_Slash */ 0x36, /* KEY_ShiftR */
-    0x37, /* KEY_KP_Multiply */ 0x38,   /* KEY_Alt */
-    0x39, /* KEY_Space */ 0x3a, /* KEY_CapsLock */
-    0x3b, /* KEY_F1 */ 0x3c,    /* KEY_F2 */
-    0x3d, /* KEY_F3 */ 0x3e,    /* KEY_F4 */
-    0x3f, /* KEY_F5 */ 0x40,    /* KEY_F6 */
-    0x41, /* KEY_F7 */ 0x42,    /* KEY_F8 */
-    0x43, /* KEY_F9 */ 0x44,    /* KEY_F10 */
-    0x45, /* KEY_NumLock */ 0x46,       /* KEY_ScrollLock */
-    0x47, /* KEY_KP_7 */ 0x48,  /* KEY_KP_8 */
-    0x49, /* KEY_KP_9 */ 0x4a,  /* KEY_KP_Minus */
-    0x4b, /* KEY_KP_4 */ 0x4c,  /* KEY_KP_5 */
-    0x4d, /* KEY_KP_6 */ 0x4e,  /* KEY_KP_Plus */
-    0x4f, /* KEY_KP_1 */ 0x50,  /* KEY_KP_2 */
-    0x51, /* KEY_KP_3 */ 0x52,  /* KEY_KP_0 */
-    0x53, /* KEY_KP_Decimal */ 0x54,    /* KEY_SysReqest */
-    0x00, /* 0x55 */ 0x56,      /* KEY_Less */
-    0x57, /* KEY_F11 */ 0x58,   /* KEY_F12 */
-    0x66, /* KEY_Home */ 0x67,  /* KEY_Up */
-    0x68, /* KEY_PgUp */ 0x69,  /* KEY_Left */
-    0x5d, /* KEY_Begin */ 0x6a, /* KEY_Right */
-    0x6b, /* KEY_End */ 0x6c,   /* KEY_Down */
-    0x6d, /* KEY_PgDown */ 0x6e,        /* KEY_Insert */
-    0x6f, /* KEY_Delete */ 0x60,        /* KEY_KP_Enter */
-    0x61, /* KEY_RCtrl */ 0x77, /* KEY_Pause */
-    0x63, /* KEY_Print */ 0x62, /* KEY_KP_Divide */
-    0x64, /* KEY_AltLang */ 0x65,       /* KEY_Break */
-    0x00, /* KEY_LMeta */ 0x00, /* KEY_RMeta */
-    0x7A, /* KEY_Menu/FOCUS_PF11 */ 0x00,       /* 0x6e */
-    0x7B, /* FOCUS_PF12 */ 0x00,        /* 0x70 */
-    0x00, /* 0x71 */ 0x00,      /* 0x72 */
-    0x59, /* FOCUS_PF2 */ 0x78, /* FOCUS_PF9 */
-    0x00, /* 0x75 */ 0x00,      /* 0x76 */
-    0x5A, /* FOCUS_PF3 */ 0x5B, /* FOCUS_PF4 */
-    0x5C, /* FOCUS_PF5 */ 0x5D, /* FOCUS_PF6 */
-    0x5E, /* FOCUS_PF7 */ 0x5F, /* FOCUS_PF8 */
-    0x7C, /* JAP_86 */ 0x79,    /* FOCUS_PF10 */
-    0x00,                       /* 0x7f */
-};
-
-#define NUM_AT_KEYS (sizeof(at2lnx)/sizeof(at2lnx[0]))
-#define LNX_KEY_INDEX(n) n < NUM_AT_KEYS ? at2lnx[n] : 0
-
-static unsigned char tbl[KD_MAX_WIDTH] = {
-    0,
-    1 << KG_SHIFT,
-    (1 << KG_ALTGR),
-    (1 << KG_ALTGR) | (1 << KG_SHIFT)
-};
-#endif
-
-static void
-readKernelMapping(KdKeyboardInfo * ki)
-{
-#if 0
-    KeySym *k;
-    int i, j;
-    struct kbentry kbe;
-    int minKeyCode, maxKeyCode;
-    int row;
-    int fd;
-
-    if (!ki)
-        return;
-
-    fd = LinuxConsoleFd;
-
-    minKeyCode = NR_KEYS;
-    maxKeyCode = 0;
-    row = 0;
-    ki->keySyms.mapWidth = KD_MAX_WIDTH;
-    for (i = 0; i < NR_KEYS && row < KD_MAX_LENGTH; ++i) {
-        kbe.kb_index = LNX_KEY_INDEX(i);
-
-        k = ki->keySyms.map + row * ki->keySyms.mapWidth;
-
-        for (j = 0; j < ki->keySyms.mapWidth; ++j) {
-            unsigned short kval;
-
-            k[j] = NoSymbol;
-
-            kbe.kb_table = tbl[j];
-            kbe.kb_value = 0;
-            if (ioctl(fd, KDGKBENT, &kbe))
-                continue;
-
-            kval = KVAL(kbe.kb_value);
-            switch (KTYP(kbe.kb_value)) {
-            case KT_LATIN:
-            case KT_LETTER:
-                k[j] = linux_to_x[kval];
-                break;
-
-            case KT_FN:
-                if (kval <= 19)
-                    k[j] = XK_F1 + kval;
-                else
-                    switch (kbe.kb_value) {
-                    case K_FIND:
-                        k[j] = XK_Home; /* or XK_Find */
-                        break;
-                    case K_INSERT:
-                        k[j] = XK_Insert;
-                        break;
-                    case K_REMOVE:
-                        k[j] = XK_Delete;
-                        break;
-                    case K_SELECT:
-                        k[j] = XK_End;  /* or XK_Select */
-                        break;
-                    case K_PGUP:
-                        k[j] = XK_Prior;
-                        break;
-                    case K_PGDN:
-                        k[j] = XK_Next;
-                        break;
-                    case K_HELP:
-                        k[j] = XK_Help;
-                        break;
-                    case K_DO:
-                        k[j] = XK_Execute;
-                        break;
-                    case K_PAUSE:
-                        k[j] = XK_Pause;
-                        break;
-                    case K_MACRO:
-                        k[j] = XK_Menu;
-                        break;
-                    default:
-                        break;
-                    }
-                break;
-
-            case KT_SPEC:
-                switch (kbe.kb_value) {
-                case K_ENTER:
-                    k[j] = XK_Return;
-                    break;
-                case K_BREAK:
-                    k[j] = XK_Break;
-                    break;
-                case K_CAPS:
-                    k[j] = XK_Caps_Lock;
-                    break;
-                case K_NUM:
-                    k[j] = XK_Num_Lock;
-                    break;
-                case K_HOLD:
-                    k[j] = XK_Scroll_Lock;
-                    break;
-                case K_COMPOSE:
-                    k[j] = XK_Multi_key;
-                    break;
-                default:
-                    break;
-                }
-                break;
-
-            case KT_PAD:
-                switch (kbe.kb_value) {
-                case K_PPLUS:
-                    k[j] = XK_KP_Add;
-                    break;
-                case K_PMINUS:
-                    k[j] = XK_KP_Subtract;
-                    break;
-                case K_PSTAR:
-                    k[j] = XK_KP_Multiply;
-                    break;
-                case K_PSLASH:
-                    k[j] = XK_KP_Divide;
-                    break;
-                case K_PENTER:
-                    k[j] = XK_KP_Enter;
-                    break;
-                case K_PCOMMA:
-                    k[j] = XK_KP_Separator;
-                    break;
-                case K_PDOT:
-                    k[j] = XK_KP_Decimal;
-                    break;
-                case K_PPLUSMINUS:
-                    k[j] = XK_KP_Subtract;
-                    break;
-                default:
-                    if (kval <= 9)
-                        k[j] = XK_KP_0 + kval;
-                    break;
-                }
-                break;
-
-                /*
-                 * KT_DEAD keys are for accelerated diacritical creation.
-                 */
-            case KT_DEAD:
-                switch (kbe.kb_value) {
-                case K_DGRAVE:
-                    k[j] = XK_dead_grave;
-                    break;
-                case K_DACUTE:
-                    k[j] = XK_dead_acute;
-                    break;
-                case K_DCIRCM:
-                    k[j] = XK_dead_circumflex;
-                    break;
-                case K_DTILDE:
-                    k[j] = XK_dead_tilde;
-                    break;
-                case K_DDIERE:
-                    k[j] = XK_dead_diaeresis;
-                    break;
-                }
-                break;
-
-            case KT_CUR:
-                switch (kbe.kb_value) {
-                case K_DOWN:
-                    k[j] = XK_Down;
-                    break;
-                case K_LEFT:
-                    k[j] = XK_Left;
-                    break;
-                case K_RIGHT:
-                    k[j] = XK_Right;
-                    break;
-                case K_UP:
-                    k[j] = XK_Up;
-                    break;
-                }
-                break;
-
-            case KT_SHIFT:
-                switch (kbe.kb_value) {
-                case K_ALTGR:
-                    k[j] = XK_Mode_switch;
-                    break;
-                case K_ALT:
-                    k[j] = (kbe.kb_index == 0x64 ? XK_Alt_R : XK_Alt_L);
-                    break;
-                case K_CTRL:
-                    k[j] = (kbe.kb_index == 0x61 ? XK_Control_R : XK_Control_L);
-                    break;
-                case K_CTRLL:
-                    k[j] = XK_Control_L;
-                    break;
-                case K_CTRLR:
-                    k[j] = XK_Control_R;
-                    break;
-                case K_SHIFT:
-                    k[j] = (kbe.kb_index == 0x36 ? XK_Shift_R : XK_Shift_L);
-                    break;
-                case K_SHIFTL:
-                    k[j] = XK_Shift_L;
-                    break;
-                case K_SHIFTR:
-                    k[j] = XK_Shift_R;
-                    break;
-                default:
-                    break;
-                }
-                break;
-
-                /*
-                 * KT_ASCII keys accumulate a 3 digit decimal number that gets
-                 * emitted when the shift state changes. We can't emulate that.
-                 */
-            case KT_ASCII:
-                break;
-
-            case KT_LOCK:
-                if (kbe.kb_value == K_SHIFTLOCK)
-                    k[j] = XK_Shift_Lock;
-                break;
-
-#ifdef KT_X
-            case KT_X:
-                /* depends on new keyboard symbols in file linux/keyboard.h */
-                if (kbe.kb_value == K_XMENU)
-                    k[j] = XK_Menu;
-                if (kbe.kb_value == K_XTELEPHONE)
-                    k[j] = XK_telephone;
-                break;
-#endif
-#ifdef KT_XF
-            case KT_XF:
-                /* special linux keysyms which map directly to XF86 keysyms */
-                k[j] = (kbe.kb_value & 0xFF) + 0x1008FF00;
-                break;
-#endif
-
-            default:
-                break;
-            }
-            if (i < minKeyCode)
-                minKeyCode = i;
-            if (i > maxKeyCode)
-                maxKeyCode = i;
-        }
-
-        if (minKeyCode == NR_KEYS)
-            continue;
-
-        if (k[3] == k[2])
-            k[3] = NoSymbol;
-        if (k[2] == k[1])
-            k[2] = NoSymbol;
-        if (k[1] == k[0])
-            k[1] = NoSymbol;
-        if (k[0] == k[2] && k[1] == k[3])
-            k[2] = k[3] = NoSymbol;
-        if (k[3] == k[0] && k[2] == k[1] && k[2] == NoSymbol)
-            k[3] = NoSymbol;
-        row++;
-    }
-    ki->minScanCode = minKeyCode;
-    ki->maxScanCode = maxKeyCode;
-#endif
-}
-
 /*
  * We need these to handle extended scancodes correctly (I could just use the
  * numbers below, but this makes the code more readable
@@ -759,8 +320,6 @@ LinuxKeyboardInit(KdKeyboardInfo * ki)
     free(ki->name);
     ki->name = strdup("Linux console keyboard");
 
-    readKernelMapping(ki);
-
     return Success;
 }
 
diff --git a/hw/xfree86/common/xf86Config.c b/hw/xfree86/common/xf86Config.c
index 0c067c0..07f8fb4 100644
--- a/hw/xfree86/common/xf86Config.c
+++ b/hw/xfree86/common/xf86Config.c
@@ -700,6 +700,7 @@ typedef enum {
     FLAG_USE_SIGIO,
     FLAG_AUTO_ADD_GPU,
     FLAG_MAX_CLIENTS,
+    FLAG_IGLX,
 } FlagValues;
 
 /**
@@ -761,6 +762,8 @@ static OptionInfoRec FlagOptions[] = {
      {0}, FALSE},
     {FLAG_MAX_CLIENTS, "MaxClients", OPTV_INTEGER,
      {0}, FALSE },
+    {FLAG_IGLX, "IndirectGLX", OPTV_BOOLEAN,
+     {0}, FALSE},
     {-1, NULL, OPTV_NONE,
      {0}, FALSE},
 };
@@ -943,6 +946,12 @@ configServerFlags(XF86ConfFlagsPtr flagsconf, XF86OptionPtr layoutopts)
         xf86Info.aiglx = value;
         xf86Info.aiglxFrom = X_CONFIG;
     }
+    if (xf86Info.iglxFrom != X_CMDLINE) {
+        if (xf86GetOptValBool(FlagOptions, FLAG_IGLX, &value)) {
+            enableIndirectGLX = value;
+            xf86Info.iglxFrom = X_CONFIG;
+        }
+    }
 #endif
 
     /* if we're not hotplugging, force some input devices to exist */
diff --git a/hw/xfree86/common/xf86Configure.c b/hw/xfree86/common/xf86Configure.c
index 1271010..59d275e 100644
--- a/hw/xfree86/common/xf86Configure.c
+++ b/hw/xfree86/common/xf86Configure.c
@@ -264,7 +264,7 @@ configureDeviceSection(int screennum)
     ptr->dev_busid = DevToConfig[screennum].GDev.busID;
     ptr->dev_driver = DevToConfig[screennum].GDev.driver;
     ptr->dev_ramdac = DevToConfig[screennum].GDev.ramdac;
-    for (i = 0; (i < MAXDACSPEEDS) && (i < CONF_MAXDACSPEEDS); i++)
+    for (i = 0; i < MAXDACSPEEDS; i++)
         ptr->dev_dacSpeeds[i] = DevToConfig[screennum].GDev.dacSpeeds[i];
     ptr->dev_videoram = DevToConfig[screennum].GDev.videoRam;
     ptr->dev_bios_base = DevToConfig[screennum].GDev.BiosBase;
diff --git a/hw/xfree86/common/xf86Init.c b/hw/xfree86/common/xf86Init.c
index de51497..9bade90 100644
--- a/hw/xfree86/common/xf86Init.c
+++ b/hw/xfree86/common/xf86Init.c
@@ -1457,6 +1457,10 @@ ddxProcessArgument(int argc, char **argv, int i)
         xf86Info.ShareVTs = TRUE;
         return 1;
     }
+    if (!strcmp(argv[i], "-iglx") || !strcmp(argv[i], "+iglx")) {
+        xf86Info.iglxFrom = X_CMDLINE;
+        return 0;
+    }
 
     /* OS-specific processing */
     return xf86ProcessArgument(argc, argv, i);
diff --git a/hw/xfree86/common/xf86Privstr.h b/hw/xfree86/common/xf86Privstr.h
index 58d5a0f..c5d24ea 100644
--- a/hw/xfree86/common/xf86Privstr.h
+++ b/hw/xfree86/common/xf86Privstr.h
@@ -89,6 +89,7 @@ typedef struct {
     MessageType randRFrom;
     Bool aiglx;
     MessageType aiglxFrom;
+    MessageType iglxFrom;
     XF86_GlxVisuals glxVisuals;
     MessageType glxVisualsFrom;
 
diff --git a/hw/xfree86/drivers/modesetting/driver.c b/hw/xfree86/drivers/modesetting/driver.c
index 8f60eae..b05ad81 100644
--- a/hw/xfree86/drivers/modesetting/driver.c
+++ b/hw/xfree86/drivers/modesetting/driver.c
@@ -214,14 +214,26 @@ open_hw(const char *dev)
 }
 
 static int
-check_outputs(int fd)
+check_outputs(int fd, int *count)
 {
     drmModeResPtr res = drmModeGetResources(fd);
     int ret;
 
     if (!res)
         return FALSE;
+
+    if (count)
+        *count = res->count_connectors;
+
     ret = res->count_connectors > 0;
+#if defined DRM_CAP_PRIME && GLAMOR_HAS_GBM_LINEAR
+    if (ret == FALSE) {
+        uint64_t value = 0;
+        if (drmGetCap(fd, DRM_CAP_PRIME, &value) == 0 &&
+                (value & DRM_PRIME_CAP_EXPORT))
+            ret = TRUE;
+    }
+#endif
     drmModeFreeResources(res);
     return ret;
 }
@@ -236,13 +248,13 @@ probe_hw(const char *dev, struct xf86_platform_device *platform_dev)
         fd = xf86_platform_device_odev_attributes(platform_dev)->fd;
         if (fd == -1)
             return FALSE;
-        return check_outputs(fd);
+        return check_outputs(fd, NULL);
     }
 #endif
 
     fd = open_hw(dev);
     if (fd != -1) {
-        int ret = check_outputs(fd);
+        int ret = check_outputs(fd, NULL);
 
         close(fd);
         return ret;
@@ -285,7 +297,7 @@ probe_hw_pci(const char *dev, struct pci_device *pdev)
     devid = ms_DRICreatePCIBusID(pdev);
 
     if (id && devid && !strcmp(id, devid))
-        ret = check_outputs(fd);
+        ret = check_outputs(fd, NULL);
 
     close(fd);
     free(id);
@@ -624,7 +636,6 @@ FreeRec(ScrnInfoPtr pScrn)
     ms = modesettingPTR(pScrn);
     if (!ms)
         return;
-    pScrn->driverPrivate = NULL;
 
     if (ms->fd > 0) {
         modesettingEntPtr ms_ent;
@@ -645,6 +656,7 @@ FreeRec(ScrnInfoPtr pScrn)
             ms_ent->fd = 0;
         }
     }
+    pScrn->driverPrivate = NULL;
     free(ms->drmmode.Options);
     free(ms);
 
@@ -772,7 +784,7 @@ PreInit(ScrnInfoPtr pScrn, int flags)
     EntityInfoPtr pEnt;
     uint64_t value = 0;
     int ret;
-    int bppflags;
+    int bppflags, connector_count;
     int defaultdepth, defaultbpp;
 
     if (pScrn->numEntities != 1)
@@ -809,18 +821,9 @@ PreInit(ScrnInfoPtr pScrn, int flags)
         return FALSE;
     ms->drmmode.fd = ms->fd;
 
-    pScrn->capabilities = 0;
-#ifdef DRM_CAP_PRIME
-    ret = drmGetCap(ms->fd, DRM_CAP_PRIME, &value);
-    if (ret == 0) {
-        if (value & DRM_PRIME_CAP_IMPORT)
-            pScrn->capabilities |= RR_Capability_SinkOutput;
-#if GLAMOR_HAS_GBM_LINEAR
-        if (value & DRM_PRIME_CAP_EXPORT)
-            pScrn->capabilities |= RR_Capability_SourceOutput;
-#endif
-    }
-#endif
+    if (!check_outputs(ms->fd, &connector_count))
+        return FALSE;
+
     drmmode_get_default_bpp(pScrn, &ms->drmmode, &defaultdepth, &defaultbpp);
     if (defaultdepth == 24 && defaultbpp == 24)
         bppflags = SupportConvert32to24 | Support24bppFb;
@@ -896,6 +899,22 @@ PreInit(ScrnInfoPtr pScrn, int flags)
         ms->drmmode.pageflip = FALSE;
     }
 
+    pScrn->capabilities = 0;
+#ifdef DRM_CAP_PRIME
+    ret = drmGetCap(ms->fd, DRM_CAP_PRIME, &value);
+    if (ret == 0) {
+        if (connector_count && (value & DRM_PRIME_CAP_IMPORT)) {
+            pScrn->capabilities |= RR_Capability_SinkOutput;
+            if (ms->drmmode.glamor)
+                pScrn->capabilities |= RR_Capability_SinkOffload;
+        }
+#if GLAMOR_HAS_GBM_LINEAR
+        if (value & DRM_PRIME_CAP_EXPORT && ms->drmmode.glamor)
+            pScrn->capabilities |= RR_Capability_SourceOutput | RR_Capability_SourceOffload;
+#endif
+    }
+#endif
+
     if (drmmode_pre_init(pScrn, &ms->drmmode, pScrn->bitsPerPixel / 8) == FALSE) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "KMS setup failed\n");
         goto fail;
@@ -912,7 +931,7 @@ PreInit(ScrnInfoPtr pScrn, int flags)
         }
     }
 
-    if (pScrn->modes == NULL) {
+    if (!(pScrn->is_gpu && connector_count == 0) && pScrn->modes == NULL) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No modes.\n");
         return FALSE;
     }
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.c b/hw/xfree86/drivers/modesetting/drmmode_display.c
index bb5f56e..e710b03 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.c
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.c
@@ -484,7 +484,7 @@ drmmode_set_cursor_position(xf86CrtcPtr crtc, int x, int y)
     drmModeMoveCursor(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id, x, y);
 }
 
-static void
+static Bool
 drmmode_set_cursor(xf86CrtcPtr crtc)
 {
     drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
@@ -503,9 +503,9 @@ drmmode_set_cursor(xf86CrtcPtr crtc)
                               handle, ms->cursor_width, ms->cursor_height,
                               cursor->bits->xhot, cursor->bits->yhot);
         if (!ret)
-            return;
-        if (ret == -EINVAL)
-            use_set_cursor2 = FALSE;
+            return TRUE;
+
+        use_set_cursor2 = FALSE;
     }
 
     ret = drmModeSetCursor(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id, handle,
@@ -518,16 +518,28 @@ drmmode_set_cursor(xf86CrtcPtr crtc)
         cursor_info->MaxWidth = cursor_info->MaxHeight = 0;
         drmmode_crtc->drmmode->sw_cursor = TRUE;
         /* fallback to swcursor */
+        return FALSE;
     }
+    return TRUE;
 }
 
-static void
-drmmode_load_cursor_argb(xf86CrtcPtr crtc, CARD32 *image)
+static void drmmode_hide_cursor(xf86CrtcPtr crtc);
+
+/*
+ * The load_cursor_argb_check driver hook.
+ *
+ * Sets the hardware cursor by calling the drmModeSetCursor2 ioctl.
+ * On failure, returns FALSE indicating that the X server should fall
+ * back to software cursors.
+ */
+static Bool
+drmmode_load_cursor_argb_check(xf86CrtcPtr crtc, CARD32 *image)
 {
     modesettingPtr ms = modesettingPTR(crtc->scrn);
     drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
     int i;
     uint32_t *ptr;
+    static Bool first_time = TRUE;
 
     /* cursor should be mapped already */
     ptr = (uint32_t *) (drmmode_crtc->cursor_bo->ptr);
@@ -535,8 +547,14 @@ drmmode_load_cursor_argb(xf86CrtcPtr crtc, CARD32 *image)
     for (i = 0; i < ms->cursor_width * ms->cursor_height; i++)
         ptr[i] = image[i];      // cpu_to_le32(image[i]);
 
-    if (drmmode_crtc->cursor_up)
-        drmmode_set_cursor(crtc);
+    if (drmmode_crtc->cursor_up || first_time) {
+        Bool ret = drmmode_set_cursor(crtc);
+        if (!drmmode_crtc->cursor_up)
+            drmmode_hide_cursor(crtc);
+        first_time = FALSE;
+        return ret;
+    }
+    return TRUE;
 }
 
 static void
@@ -577,11 +595,17 @@ drmmode_set_scanout_pixmap_gpu(xf86CrtcPtr crtc, PixmapPtr ppix)
     PixmapPtr screenpix = screen->GetScreenPixmap(screen);
     xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
     drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+    drmmode_ptr drmmode = drmmode_crtc->drmmode;
     int c, total_width = 0, max_height = 0, this_x = 0;
 
     if (!ppix) {
-        if (crtc->randr_crtc->scanout_pixmap)
+        if (crtc->randr_crtc->scanout_pixmap) {
             PixmapStopDirtyTracking(crtc->randr_crtc->scanout_pixmap, screenpix);
+            if (drmmode->fb_id) {
+                drmModeRmFB(drmmode->fd, drmmode->fb_id);
+                drmmode->fb_id = 0;
+            }
+        }
         drmmode_crtc->prime_pixmap_x = 0;
         return TRUE;
     }
@@ -799,7 +823,7 @@ static const xf86CrtcFuncsRec drmmode_crtc_funcs = {
     .set_cursor_position = drmmode_set_cursor_position,
     .show_cursor = drmmode_show_cursor,
     .hide_cursor = drmmode_hide_cursor,
-    .load_cursor_argb = drmmode_load_cursor_argb,
+    .load_cursor_argb_check = drmmode_load_cursor_argb_check,
 
     .gamma_set = drmmode_crtc_gamma_set,
     .destroy = NULL,            /* XXX */
@@ -1633,10 +1657,8 @@ static Bool
 drmmode_xf86crtc_resize(ScrnInfoPtr scrn, int width, int height)
 {
     xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
-
-    drmmode_crtc_private_ptr
-        drmmode_crtc = xf86_config->crtc[0]->driver_private;
-    drmmode_ptr drmmode = drmmode_crtc->drmmode;
+    modesettingPtr ms = modesettingPTR(scrn);
+    drmmode_ptr drmmode = &ms->drmmode;
     drmmode_bo old_front;
     Bool ret;
     ScreenPtr screen = xf86ScrnToScreen(scrn);
diff --git a/hw/xfree86/drivers/modesetting/present.c b/hw/xfree86/drivers/modesetting/present.c
index d65c8c8..9a596de 100644
--- a/hw/xfree86/drivers/modesetting/present.c
+++ b/hw/xfree86/drivers/modesetting/present.c
@@ -626,6 +626,15 @@ ms_present_unflip(ScreenPtr screen, uint64_t event_id)
 	if (!crtc->enabled)
 	    continue;
 
+	/* info->drmmode.fb_id still points to the FB for the last flipped BO.
+	 * Clear it, drmmode_set_mode_major will re-create it
+	 */
+	if (drmmode_crtc->drmmode->fb_id) {
+		drmModeRmFB(drmmode_crtc->drmmode->fd,
+			    drmmode_crtc->drmmode->fb_id);
+		drmmode_crtc->drmmode->fb_id = 0;
+	}
+
 	if (drmmode_crtc->dpms_mode == DPMSModeOn)
 	    crtc->funcs->set_mode_major(crtc, &crtc->mode, crtc->rotation,
 					crtc->x, crtc->y);
diff --git a/hw/xfree86/int10/xf86x86emu.c b/hw/xfree86/int10/xf86x86emu.c
index 4b0a130..1dc695d 100644
--- a/hw/xfree86/int10/xf86x86emu.c
+++ b/hw/xfree86/int10/xf86x86emu.c
@@ -7,13 +7,13 @@
 #include <xorg-config.h>
 #endif
 
-#include <x86emu.h>
 #include "xf86.h"
 #include "xf86_OSproc.h"
 #include "xf86Pci.h"
 #define _INT10_PRIVATE
 #include "xf86int10.h"
 #include "int10Defines.h"
+#include <x86emu.h>
 
 #define M _X86EMU_env
 
diff --git a/hw/xfree86/man/xorg.conf.man b/hw/xfree86/man/xorg.conf.man
index 08eb7a9..e33114d 100644
--- a/hw/xfree86/man/xorg.conf.man
+++ b/hw/xfree86/man/xorg.conf.man
@@ -644,6 +644,10 @@ Default is disabled.
 .BI "Option \*qAIGLX\*q \*q" boolean \*q
 enable or disable AIGLX. AIGLX is enabled by default.
 .TP 7
+.BI "Option \*qIndirectGLX\*q \*q" boolean \*q
+enable or disable indirect GLX contexts. Indirect GLX contexts are disabled by
+default.
+.TP 7
 .BI "Option \*qDRI2\*q \*q" boolean \*q
 enable or disable DRI2. DRI2 is disabled by default.
 .TP 7
diff --git a/hw/xfree86/modes/xf86Crtc.c b/hw/xfree86/modes/xf86Crtc.c
index 6091b5e..4a13c13 100644
--- a/hw/xfree86/modes/xf86Crtc.c
+++ b/hw/xfree86/modes/xf86Crtc.c
@@ -3285,7 +3285,8 @@ xf86OutputSetEDID(xf86OutputPtr output, xf86MonPtr edid_mon)
     }
 
     /* Set the DDC properties for the 'compat' output */
-    if (output == xf86CompatOutput(scrn))
+    /* GPU screens don't have a root window */
+    if (output == xf86CompatOutput(scrn) && !scrn->is_gpu)
         xf86SetDDCproperties(scrn, edid_mon);
 
 #ifdef RANDR_12_INTERFACE
diff --git a/hw/xfree86/x86emu/x86emu/regs.h b/hw/xfree86/x86emu/x86emu/regs.h
index c040259..3c9469f 100644
--- a/hw/xfree86/x86emu/x86emu/regs.h
+++ b/hw/xfree86/x86emu/x86emu/regs.h
@@ -158,14 +158,6 @@ struct i386_segment_regs {
 #define R_FLG spc.FLAGS
 
 /* special registers */
-#define R_SP  spc.SP.I16_reg.x_reg
-#define R_BP  spc.BP.I16_reg.x_reg
-#define R_SI  spc.SI.I16_reg.x_reg
-#define R_DI  spc.DI.I16_reg.x_reg
-#define R_IP  spc.IP.I16_reg.x_reg
-#define R_FLG spc.FLAGS
-
-/* special registers */
 #define R_ESP  spc.SP.I32_reg.e_reg
 #define R_EBP  spc.BP.I32_reg.e_reg
 #define R_ESI  spc.SI.I32_reg.e_reg
diff --git a/hw/xquartz/bundle/Info.plist.cpp b/hw/xquartz/bundle/Info.plist.cpp
index 06e33f8..3742353 100644
--- a/hw/xquartz/bundle/Info.plist.cpp
+++ b/hw/xquartz/bundle/Info.plist.cpp
@@ -19,9 +19,9 @@
 	<key>CFBundlePackageType</key>
 		<string>APPL</string>
 	<key>CFBundleShortVersionString</key>
-		<string>2.7.7</string>
+		<string>BUNDLE_VERSION_STRING</string>
 	<key>CFBundleVersion</key>
-		<string>2.7.7</string>
+		<string>BUNDLE_VERSION</string>
 	<key>CFBundleSignature</key>
 		<string>x11a</string>
 	<key>CSResourcesFileMapped</key>
@@ -34,27 +34,14 @@
 	<key>SUPublicDSAKeyFile</key>
 		<string>sparkle.pem</string>
         <key>SUFeedURL</key>
-                <string>http://xquartz.macosforge.org/downloads/sparkle/release.xml</string>
-	<key>NSAppTransportSecurity</key>
-	<dict>
-		<key>NSExceptionDomains</key>
-		<dict>
-			<key>macosforge.org</key>
-			<dict>
-				<key>NSIncludesSubdomains</key>
-				<true/>
-				<key>NSExceptionAllowsInsecureHTTPLoads</key>
-				<true/>
-			</dict>
-		</dict>
-	</dict>
+                <string>XQUARTZ_SPARKLE_FEED_URL</string>
 #endif
 	<key>LSApplicationCategoryType</key>
 		<string>public.app-category.utilities</string>
 	<key>NSHumanReadableCopyright</key>
-		<string> 2003-2013 Apple Inc.
+		<string> 2003-2016 Apple Inc.
  2003 XFree86 Project, Inc.
- 2003-2013 X.org Foundation, Inc.
+ 2003-2016 X.org Foundation, Inc.
 </string>
 	<key>NSMainNibFile</key>
 		<string>main</string>
diff --git a/hw/xquartz/bundle/Makefile.am b/hw/xquartz/bundle/Makefile.am
index 0740752..424a747 100644
--- a/hw/xquartz/bundle/Makefile.am
+++ b/hw/xquartz/bundle/Makefile.am
@@ -1,11 +1,13 @@
 include cpprules.in
 
 CPP_FILES_FLAGS = \
+	-DAPPLE_APPLICATION_NAME="$(APPLE_APPLICATION_NAME)" \
 	-DBUNDLE_ID_PREFIX="$(BUNDLE_ID_PREFIX)" \
-	-DAPPLE_APPLICATION_NAME="$(APPLE_APPLICATION_NAME)"
+	-DBUNDLE_VERSION="$(BUNDLE_VERSION)" \
+	-DBUNDLE_VERSION_STRING="$(BUNDLE_VERSION_STRING)"
 
 if XQUARTZ_SPARKLE
-CPP_FILES_FLAGS += -DXQUARTZ_SPARKLE
+CPP_FILES_FLAGS += -DXQUARTZ_SPARKLE -DXQUARTZ_SPARKLE_FEED_URL="$(XQUARTZ_SPARKLE_FEED_URL)"
 endif
 
 install-data-hook:
diff --git a/hw/xwayland/xwayland-cursor.c b/hw/xwayland/xwayland-cursor.c
index 76729db..74dfe4e 100644
--- a/hw/xwayland/xwayland-cursor.c
+++ b/hw/xwayland/xwayland-cursor.c
@@ -76,8 +76,20 @@ static Bool
 xwl_unrealize_cursor(DeviceIntPtr device, ScreenPtr screen, CursorPtr cursor)
 {
     PixmapPtr pixmap;
+    struct xwl_seat *xwl_seat;
 
     pixmap = dixGetPrivate(&cursor->devPrivates, &xwl_cursor_private_key);
+    if (!pixmap)
+        return TRUE;
+
+    dixSetPrivate(&cursor->devPrivates, &xwl_cursor_private_key, NULL);
+
+    /* When called from FreeCursor(), device is always NULL */
+    if (device) {
+        xwl_seat = device->public.devicePrivate;
+        if (xwl_seat && cursor == xwl_seat->x_cursor)
+            xwl_seat->x_cursor = NULL;
+    }
 
     return xwl_shm_destroy_pixmap(pixmap);
 }
@@ -122,6 +134,9 @@ xwl_seat_set_cursor(struct xwl_seat *xwl_seat)
 
     cursor = xwl_seat->x_cursor;
     pixmap = dixGetPrivate(&cursor->devPrivates, &xwl_cursor_private_key);
+    if (!pixmap)
+        return;
+
     stride = cursor->bits->width * 4;
     if (cursor->bits->argb)
         memcpy(pixmap->devPrivate.ptr,
diff --git a/hw/xwayland/xwayland-glamor-xv.c b/hw/xwayland/xwayland-glamor-xv.c
index c99418d..65f93c6 100644
--- a/hw/xwayland/xwayland-glamor-xv.c
+++ b/hw/xwayland/xwayland-glamor-xv.c
@@ -336,7 +336,7 @@ xwl_glamor_xv_add_adaptors(ScreenPtr pScreen)
 
     pa = xnfcalloc(1, sizeof(XvAdaptorRec));
     pa->pScreen = pScreen;
-    pa->type = (unsigned int) (XvWindowMask | XvInputMask | XvImageMask);
+    pa->type = (unsigned char) (XvInputMask | XvImageMask);
     pa->ddStopVideo = xwl_glamor_xv_stop_video;
     pa->ddPutImage = xwl_glamor_xv_put_image;
     pa->ddSetPortAttribute = xwl_glamor_xv_set_port_attribute;
diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index 04aa8f2..a7ae786 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -298,12 +298,13 @@ xwl_drm_init_egl(struct xwl_screen *xwl_screen)
         return;
     }
 
-    eglBindAPI(EGL_OPENGL_API);
     if (!eglInitialize(xwl_screen->egl_display, &major, &minor)) {
         ErrorF("eglInitialize() failed\n");
         return;
     }
 
+    eglBindAPI(EGL_OPENGL_API);
+
     version = eglQueryString(xwl_screen->egl_display, EGL_VERSION);
     ErrorF("glamor: EGL version %s:\n", version);
 
diff --git a/hw/xwayland/xwayland-shm.c b/hw/xwayland/xwayland-shm.c
index e8545b3..c199e5e 100644
--- a/hw/xwayland/xwayland-shm.c
+++ b/hw/xwayland/xwayland-shm.c
@@ -140,14 +140,20 @@ os_create_anonymous_file(off_t size)
         return -1;
 
 #ifdef HAVE_POSIX_FALLOCATE
-    ret = posix_fallocate(fd, 0, size);
+    do {
+        ret = posix_fallocate(fd, 0, size);
+    } while (ret == EINTR);
+
     if (ret != 0) {
         close(fd);
         errno = ret;
         return -1;
     }
 #else
-    ret = ftruncate(fd, size);
+    do {
+        ret = ftruncate(fd, size);
+    } while (ret == -1 && errno == EINTR);
+
     if (ret < 0) {
         close(fd);
         return -1;
diff --git a/include/xkbsrv.h b/include/xkbsrv.h
index cc6307a..7e71089 100644
--- a/include/xkbsrv.h
+++ b/include/xkbsrv.h
@@ -496,6 +496,10 @@ extern _X_EXPORT void XkbUpdateIndicators(DeviceIntPtr /* keybd */ ,
                                           XkbEventCausePtr      /* cause */
     );
 
+extern _X_EXPORT void XkbUpdateAllDeviceIndicators(XkbChangesPtr /* changes */,
+                                                   XkbEventCausePtr /* cause */
+    );
+
 extern _X_EXPORT XkbSrvLedInfoPtr XkbAllocSrvLedInfo(DeviceIntPtr /* dev */ ,
                                                      KbdFeedbackPtr /* kf */ ,
                                                      LedFeedbackPtr /* lf */ ,
diff --git a/present/present.c b/present/present.c
index 105e2bf..cebd2f7 100644
--- a/present/present.c
+++ b/present/present.c
@@ -353,10 +353,10 @@ present_re_execute(present_vblank_ptr vblank)
 static void
 present_flip_try_ready(ScreenPtr screen)
 {
-    present_vblank_ptr  vblank, tmp;
+    present_vblank_ptr  vblank;
 
-    xorg_list_for_each_entry_safe(vblank, tmp, &present_exec_queue, event_queue) {
-        if (vblank->flip_ready) {
+    xorg_list_for_each_entry(vblank, &present_flip_queue, event_queue) {
+        if (vblank->queued) {
             present_re_execute(vblank);
             return;
         }
@@ -517,19 +517,22 @@ present_flip_notify(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
 void
 present_event_notify(uint64_t event_id, uint64_t ust, uint64_t msc)
 {
-    present_vblank_ptr  vblank, tmp;
+    present_vblank_ptr  vblank;
     int                 s;
 
     if (!event_id)
         return;
     DebugPresent(("\te %lld ust %lld msc %lld\n", event_id, ust, msc));
-    xorg_list_for_each_entry_safe(vblank, tmp, &present_exec_queue, event_queue) {
-        if (vblank->event_id == event_id) {
+    xorg_list_for_each_entry(vblank, &present_exec_queue, event_queue) {
+        int64_t match = event_id - vblank->event_id;
+        if (match == 0) {
             present_execute(vblank, ust, msc);
             return;
         }
+        if (match < 0)
+            break;
     }
-    xorg_list_for_each_entry_safe(vblank, tmp, &present_flip_queue, event_queue) {
+    xorg_list_for_each_entry(vblank, &present_flip_queue, event_queue) {
         if (vblank->event_id == event_id) {
             present_flip_notify(vblank, ust, msc);
             return;
@@ -653,6 +656,8 @@ present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
             DebugPresent(("\tr %lld %p (pending %p unflip %lld)\n",
                           vblank->event_id, vblank,
                           screen_priv->flip_pending, screen_priv->unflip_event_id));
+            xorg_list_del(&vblank->event_queue);
+            xorg_list_append(&vblank->event_queue, &present_flip_queue);
             vblank->flip_ready = TRUE;
             return;
         }
@@ -943,7 +948,7 @@ present_pixmap(WindowPtr window,
                       vblank->pixmap->drawable.id, vblank->window->drawable.id,
                       target_crtc, vblank->flip, vblank->sync_flip, vblank->serial));
 
-    xorg_list_add(&vblank->event_queue, &present_exec_queue);
+    xorg_list_append(&vblank->event_queue, &present_exec_queue);
     vblank->queued = TRUE;
     if (msc_is_after(target_msc, crtc_msc)) {
         ret = present_queue_vblank(screen, target_crtc, vblank->event_id, target_msc);
@@ -967,7 +972,7 @@ no_mem:
 void
 present_abort_vblank(ScreenPtr screen, RRCrtcPtr crtc, uint64_t event_id, uint64_t msc)
 {
-    present_vblank_ptr  vblank, tmp;
+    present_vblank_ptr  vblank;
 
     if (crtc == NULL)
         present_fake_abort_vblank(screen, event_id, msc);
@@ -978,16 +983,20 @@ present_abort_vblank(ScreenPtr screen, RRCrtcPtr crtc, uint64_t event_id, uint64
         (*screen_priv->info->abort_vblank) (crtc, event_id, msc);
     }
 
-    xorg_list_for_each_entry_safe(vblank, tmp, &present_exec_queue, event_queue) {
-        if (vblank->event_id == event_id) {
+    xorg_list_for_each_entry(vblank, &present_exec_queue, event_queue) {
+        int64_t match = event_id - vblank->event_id;
+        if (match == 0) {
             xorg_list_del(&vblank->event_queue);
             vblank->queued = FALSE;
             return;
         }
+        if (match < 0)
+            break;
     }
-    xorg_list_for_each_entry_safe(vblank, tmp, &present_flip_queue, event_queue) {
+    xorg_list_for_each_entry(vblank, &present_flip_queue, event_queue) {
         if (vblank->event_id == event_id) {
             xorg_list_del(&vblank->event_queue);
+            vblank->queued = FALSE;
             return;
         }
     }
diff --git a/randr/rrprovider.c b/randr/rrprovider.c
index bbb8e51..5329f41 100644
--- a/randr/rrprovider.c
+++ b/randr/rrprovider.c
@@ -325,6 +325,8 @@ ProcRRSetProviderOffloadSink(ClientPtr client)
     VERIFY_RR_PROVIDER(stuff->provider, provider, DixReadAccess);
     if (!(provider->capabilities & RR_Capability_SourceOffload))
         return BadValue;
+    if (!provider->pScreen->isGPU)
+        return BadValue;
 
     if (stuff->sink_provider) {
         VERIFY_RR_PROVIDER(stuff->sink_provider, sink_provider, DixReadAccess);
diff --git a/render/picture.h b/render/picture.h
index 087e54d..4499a00 100644
--- a/render/picture.h
+++ b/render/picture.h
@@ -211,7 +211,7 @@ typedef pixman_fixed_t xFixed;
 /* whether 't' is a well defined not obviously empty trapezoid */
 #define xTrapezoidValid(t)  ((t)->left.p1.y != (t)->left.p2.y && \
 			     (t)->right.p1.y != (t)->right.p2.y && \
-			     (int) ((t)->bottom - (t)->top) > 0)
+			     ((t)->bottom > (t)->top))
 
 /*
  * Standard NTSC luminance conversions:
diff --git a/xkb/xkb.c b/xkb/xkb.c
index 294cdf8..678f823 100644
--- a/xkb/xkb.c
+++ b/xkb/xkb.c
@@ -5692,7 +5692,6 @@ ProcXkbListComponents(ClientPtr client)
 }
 
 /***====================================================================***/
-
 int
 ProcXkbGetKbdByName(ClientPtr client)
 {
@@ -5707,6 +5706,7 @@ ProcXkbGetKbdByName(ClientPtr client)
     xkbGetGeometryReply grep = { 0 };
     XkbComponentNamesRec names = { 0 };
     XkbDescPtr xkb, new;
+    XkbEventCauseRec cause;
     unsigned char *str;
     char mapFile[PATH_MAX];
     unsigned len;
@@ -6017,6 +6017,9 @@ ProcXkbGetKbdByName(ClientPtr client)
         new = NULL;
     }
     XkbFreeComponentNames(&names, FALSE);
+    XkbSetCauseXkbReq(&cause, X_kbGetKbdByName, client);
+    XkbUpdateAllDeviceIndicators(NULL, &cause);
+
     return Success;
 }
 
diff --git a/xkb/xkbEvents.c b/xkb/xkbEvents.c
index 0dbbd6c..0bbd661 100644
--- a/xkb/xkbEvents.c
+++ b/xkb/xkbEvents.c
@@ -505,7 +505,7 @@ XkbHandleBell(BOOL force,
     if ((!interest) || (force))
         return;
 
-    if ((class == 0) || (class == KbdFeedbackClass)) {
+    if (class == KbdFeedbackClass) {
         KeybdCtrl *pKeyCtrl = (KeybdCtrl *) pCtrl;
 
         id = pKeyCtrl->id;
diff --git a/xkb/xkbLEDs.c b/xkb/xkbLEDs.c
index 4e16002..5792d9f 100644
--- a/xkb/xkbLEDs.c
+++ b/xkb/xkbLEDs.c
@@ -304,7 +304,7 @@ XkbUpdateLedAutoState(DeviceIntPtr dev,
     return;
 }
 
-static void
+void
 XkbUpdateAllDeviceIndicators(XkbChangesPtr changes, XkbEventCausePtr cause)
 {
     DeviceIntPtr edev;
